(ns advent-of-code-2017.day-19
  (:require [clojure.java.io :as io]))

(def input
  "The routing map (puzzle input)."
  (-> "2017/day_19.txt"
      io/resource
      io/reader
      line-seq
      vec))

(defn move
  "Returns a tuple `[x y]` reflecting where we would reach if we proceed
  in the current direction we are heading. Takes the `state` map
  described in `step` below. Returns `nil` if called after our heading
  has already become `:done`."
  [{:keys [x y heading]}]
  (case heading
    :up    [x (dec y)]
    :down  [x (inc y)]
    :left  [(dec x) y]
    :right [(inc x) y]
    nil))  ; We must be done.

(defn next-square
  "Finds the square we will reach if we proceed in the direction we are
  heading. `state` is as described in `step`, below. Returns `nil` if
  we were already done moving. Otherwise returns a tuple of the
  character in the cell we tried to move to and the new x and y
  coordinates we'll have if the move is legal."
  [{:keys [rows] :as state}]
  (if-let [[x y] (move state)]
    [(get-in rows [y x] \ ) x y]  ; Return an empty space if we tried to move outside the map.
    nil))  ; We are done.

(def opposite
  "A map from directions to their opposites."
  {:up :down
   :down :up
   :left :right
   :right :left})

(defn find-new-direction
  "We have discovered we can no longer move in the current direction.
  Find a different direction we can move and update our heading to
  that, or to `:done` if we have reached the end of the path."
  [{:keys [heading] :as state}]
  (let [options (filter #(and (not= (opposite heading) %)
                              (not= \  (first (next-square (assoc state :heading %)))))
                        [:left :right :up :down])]
    (assoc state :heading
           (case (count options)
             0 :done
             1 (first options)
             (throw (Exception. "Found more than one new direction to go!"))))))

(defn step
  "Moves a step along the routing diagram, based on the current `state`,
  which is a map with entries `:rows` (a vector of strings holding the
  diagram), `:x` and `:y` (the current position), `:heading` (the
  direction in which we are moving, one of `:left`, `:right`, `:up`,
  `:down`, or `:done`), `:seen` (the letters that have been reached),
  and `:steps` (the number of steps we have taken, for part 2).
  Returns the updated state after moving."
  [state]
  (if-let [[reached x y] (next-square state)]
    (cond  ; We are not yet done, so check the result of a move in our current direction.
      (= reached \ )  ; Can't keep moving the same direction.
      (find-new-direction state)

      (re-matches #"\w" (str reached))  ; We have reached a letter; record and move onto it.
      (-> state
          (update :seen str reached)
          (assoc :x x)
          (assoc :y y)
          (update :steps inc))

      :else  ; Must be someother line character, so just move onto it.
      (-> state
          (assoc :x x)
          (assoc :y y)
          (update :steps inc)))
    state))  ; We are done moving, so state stays unchanged.

(defn step-sequence
  "Creates an initial state based on the starting position found on the
  map in `rows`, then returns the lazy sequence formed by applying
  `step` to that state and each resulting state in turn."
  [rows]
  (let [state {:rows    rows
               :x       (.indexOf (get rows 0) "|")
               :y       0
               :heading :down
               :seen    ""
               :steps   1}]
    (iterate step state)))

(defn run
  "Iterates the sequence of states generated by `step-sequence` for
  `rows` and returns the first state where the heading becomes
  `:done`, meaning no further movement can occur."
  [rows]
  (first (drop-while #(not= :done (:heading %)) (step-sequence rows))))

(defn part-1
  "Solves part 1 by iterating through steps from the starting point
  until we reach the end, then return the letters seen along the way."
  [rows]
  (:seen (run rows)))

(defn part-2
  "Solves part 2 by iterating through steps from the starting point
  until we reach the end, then return the number of steps taken along
  the way."
  [rows]
  (:steps (run rows)))
